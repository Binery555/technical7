<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AI Signal Studio — Mega Indicators Pack (v2) + Main Chart Engine</title>
<link rel="preconnect" href="https://unpkg.com"/>
<script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1621; --panel2:#0b1320; --ink:#e6eef7; --muted:#9eb1c7;
    --line:#1a2736; --accent:#fcd535; --up:#16a34a; --down:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    overflow-y:auto;
    background:linear-gradient(180deg,#080c12,#0b1119 30%,#0b0f14);
    color:var(--ink);
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }

  header{position:sticky;top:0;z-index:3;background:rgba(11,15,20,.85);backdrop-filter:blur(10px);border-bottom:1px solid var(--line);display:flex;gap:14px;align-items:center;padding:10px 14px;flex-wrap:wrap}
  header h1{font-size:16px;margin:0 10px 0 0;letter-spacing:.2px;color:#fff;white-space:nowrap}
  .spacer{flex:1}
  .ctrl{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .hint{font-size:12px;color:var(--muted)}
  select,input,button{background:var(--panel);color:var(--ink);border:1px solid var(--line);border-radius:10px;padding:8px 10px;font:inherit;outline:none}
  input[list]{min-width:180px}
  button{cursor:pointer}

  .wrap{padding:12px;display:grid;gap:12px}
  .card{
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid var(--line);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.25);
    position:relative;overflow:hidden;
    height:clamp(460px,72vh,920px);
  }
  /* Start in "no oscillator" mode → one row that fills all */
  .grid{display:grid;gap:12px;grid-template-rows:1fr 0px;height:100%}
  .slot{position:relative}
  .chart{position:absolute;inset:0}

  .corner-logo{
    position:absolute; z-index:2; top:8px; left:8px; width:54px; height:auto;
    opacity:.45; pointer-events:none; filter:drop-shadow(0 2px 2px rgba(0,0,0,.35));
  }

  .pill{font-size:12px;padding:4px 8px;border:1px solid var(--line);border-radius:999px;color:var(--muted)}
  .toolbar{display:flex;gap:10px;align-items:center;padding:10px;border-top:1px solid var(--line);background:rgba(15,22,33,.35)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .kvs{display:flex;gap:6px;align-items:center}
  .kvs input[type="number"]{width:90px}
  .badges{display:flex;gap:6px;flex-wrap:wrap}
  .badge{font-size:12px;background:#0e1520;border:1px solid var(--line);border-radius:999px;padding:4px 8px;display:inline-flex;gap:6px;align-items:center}
  .badge button{padding:2px 6px;border-radius:999px;border:1px solid var(--line);background:#101a28;color:#fff;cursor:pointer}
  .section-title{font-size:12px;color:var(--muted);margin-right:6px}
  .toggle{display:inline-flex;gap:6px;align-items:center}

  .sheet-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;z-index:20}
  .sheet{width:100%;max-width:720px;margin:0 auto;background:linear-gradient(180deg,#0f1621,#0b1320);border-radius:16px;border:1px solid var(--line);padding:14px 14px 18px}
  .sheet h3{margin:0 0 8px 0;font-size:14px}
  .sheet .row{margin-top:8px}
  .sheet .kv{display:flex;gap:8px;align-items:center;margin:6px 0}
  .sheet .kv input[type="number"]{width:120px}
  .sheet .bar{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
  .muted{color:var(--muted);font-size:12px}
  .ghost{background:#0c141f}
  input[type="color"]{padding:0;width:42px;height:36px;border-radius:8px;border:1px solid var(--line);background:#0e1520}
  .sheet .kv input[type="checkbox"]{width:auto;height:auto}
</style>
</head>
<body>
<header>
  <h1>AI Signal Studio — Mega Indicators</h1>

  <!-- Market selector -->
  <div class="ctrl">
    <label class="hint">Market</label>
    <select id="market">
      <option value="spot" selected>Spot</option>
      <option value="um">Futures (USDT-M)</option>
    </select>
  </div>

  <div class="spacer"></div>

  <div class="ctrl"><span class="pill" id="status">Loading markets…</span></div>

  <div class="ctrl">
    <label class="hint">Quote</label>
    <select id="quote">
      <option value="USDT" selected>USDT</option><option value="FDUSD">FDUSD</option>
      <option value="USDC">USDC</option><option value="BTC">BTC</option>
      <option value="ETH">ETH</option><option value="BNB">BNB</option>
      <option value="TRY">TRY</option>
    </select>

    <label class="hint">Symbol</label>
    <input id="symbol" list="pairs" placeholder="Select pair…"/><datalist id="pairs"></datalist>

    <label class="hint">TF</label>
    <select id="tf">
      <option value="1m">1m</option><option value="3m">3m</option>
      <option value="5m" selected>5m</option><option value="15m">15m</option><option value="30m">30m</option>
      <option value="1h">1h</option><option value="2h">2h</option><option value="4h">4h</option><option value="1d">1d</option>
    </select>
    <button id="reload">Load</button>

    <label class="hint">Range</label>
    <button id="range12">12M</button>
    <button id="range36">36M</button>
  </div>

  <div class="ctrl" style="flex:1 1 100%;gap:12px">
    <span class="section-title">Indicators</span>
    <select id="indSel">
      <optgroup label="Trend / MAs">
        <option>EMA</option><option>SMA</option><option>WMA</option><option>HMA</option>
        <option>DEMA</option><option>TEMA</option><option>VWMA</option>
      </optgroup>
      <optgroup label="Volatility / Bands">
        <option>BB</option><option>Keltner</option><option>Donchian</option><option>ATR</option>
        <option>Supertrend</option><option>PSAR</option>
      </optgroup>
      <optgroup label="Price / Overlay">
        <option>VWAP</option><option>Ichimoku</option><option>HeikinAshi</option><option>PivotClassic</option>
      </optgroup>
      <optgroup label="Oscillators">
        <option>RSI</option><option>Stochastic</option><option>StochRSI</option><option>MACD</option><option>PPO</option>
        <option>TRIX</option><option>TSI</option><option>WilliamsR</option><option>CCI</option><option>ROC</option>
        <option>Aroon</option><option>ADX</option><option>Awesome</option><option>ElderRay</option>
      </optgroup>
      <optgroup label="Volume / Flow">
        <option>Volume</option><option>OBV</option><option>MFI</option><option>CMF</option><option>ADL</option>
      </optgroup>
      <optgroup label="Custom">
        <option>bildo x</option>
      </optgroup>
    </select>

    <div id="paramRow" class="row kvs"></div>

    <label class="hint">Preset</label>
    <select id="presetSel"><option value="">— none —</option></select>
    <button id="applyPreset" class="ghost">Apply</button>
    <button id="savePreset" title="Save current params as preset">Save</button>
    <button id="delPreset" class="ghost">Delete</button>

    <button id="addInd">Add</button>
    <div class="badges" id="activeBadges"></div>

    <label class="toggle"><input type="checkbox" id="haToggle"/> <span class="hint">Use Heikin-Ashi candles</span></label>
  </div>
</header>

<div class="wrap">
  <div class="card">
    <div class="grid" id="grid">
      <div class="slot">
        <img class="corner-logo" src="https://iili.io/K7QaAD7.th.jpg" alt="logo"/>
        <div id="c-main" class="chart"></div>
      </div>
      <div class="slot" id="oscSlot"><div id="c-osc" class="chart"></div></div>
    </div>
    <div class="toolbar"><span class="hint">Tip: click any badge to edit its settings. Save presets once, reuse forever. Layout auto-saves.</span></div>
  </div>
</div>

<div id="sheetWrap" class="sheet-backdrop">
  <div class="sheet">
    <div class="row" style="justify-content:space-between;align-items:center">
      <h3 id="sheetTitle">Indicator Settings</h3>
      <button id="sheetClose">Close</button>
    </div>
    <div class="muted" id="sheetSub"></div>
    <div id="sheetParams" class="row" style="gap:16px;flex-wrap:wrap;margin-top:10px"></div>
    <div class="bar">
      <button id="sheetToggleVis" class="ghost">Toggle visibility</button>
      <button id="sheetDuplicate" class="ghost">Duplicate</button>
      <button id="sheetRemove">Remove</button>
      <button id="sheetApply">Apply</button>
    </div>
  </div>
</div>

<script>
/* ========= Shared helpers & UI refs ========= */
const $=id=>document.getElementById(id);
const els={status:$('status'),market:$('market'),quote:$('quote'),symbol:$('symbol'),pairs:$('pairs'),tf:$('tf'),
           indSel:$('indSel'),paramRow:$('paramRow'),addInd:$('addInd'),badges:$('activeBadges'),
           haToggle:$('haToggle'),oscSlot:$('oscSlot'),grid:$('grid'),
           presetSel:$('presetSel'),savePreset:$('savePreset'),applyPreset:$('applyPreset'),delPreset:$('delPreset'),
           range12:$('range12'),range36:$('range36')};
const setStatus=t=>{ els.status.textContent=t; };

const defaultColor='#fcd535';
function hexToRGBA(hex,a=1){const h=hex.replace('#','');const r=parseInt(h.slice(0,2),16),g=parseInt(h.slice(2,4),16),b=parseInt(h.slice(4,6),16);return `rgba(${r},${g},${b},${a})`;}
function setSeriesColor(series,color){ try{ series.applyOptions({color}); }catch{} }
function setPackColor(pack,color){
  const list = Array.isArray(pack.series)? pack.series : [pack.series];
  if(!color) return;
  if(list.length===1){ setSeriesColor(list[0],color); }
  else{
    const shades=[1,0.7,0.4];
    list.forEach((s,i)=> setSeriesColor(s, hexToRGBA(color,shades[i%shades.length])));
  }
}

const KEYS={PRESETS:'aiSS_presets_v2', LAYOUT:'aiSS_layout_v2'};
let EXINFO=null,BY_QUOTE={},VALID_SET=new Set();

/* ========= Market endpoints ========= */
let API_BASE=null, WS_URL_BASE=null;
function applyMarketEndpoints(){
  const m=els.market.value;
  if(m==='spot'){ API_BASE='https://api.binance.com'; WS_URL_BASE='wss://stream.binance.com:9443/ws'; }
  else{ API_BASE='https://fapi.binance.com'; WS_URL_BASE='wss://fstream.binance.com/ws'; }
}

/* ========= Exchange / Pairs ========= */
async function loadExchangeInfo(){
  setStatus('Loading markets…');
  applyMarketEndpoints();
  const path = (els.market.value==='spot') ? '/api/v3/exchangeInfo' : '/fapi/v1/exchangeInfo';
  try{
    const r=await fetch(`${API_BASE}${path}`);
    if(!r.ok) throw new Error('exchangeInfo failed');
    EXINFO=await r.json(); BY_QUOTE={}; VALID_SET=new Set();
    (EXINFO.symbols||[]).filter(s=>s.status==='TRADING').forEach(s=>{
      VALID_SET.add(s.symbol); (BY_QUOTE[s.quoteAsset] ||= []).push(s.symbol);
    });
    Object.keys(BY_QUOTE).forEach(q=>{
      BY_QUOTE[q].sort((a,b)=>{
        const majors=['BTC','ETH','BNB','SOL','XRP','ADA','DOGE','TON','AVAX','TRX','LINK','MATIC','NEAR','OP','ARB','DOT','ATOM','LTC','ETC','FIL','SEI','SUI'];
        const ba=a.replace(q,''), bb=b.replace(q,'');
        const pa=majors.includes(ba)?0:1, pb=majors.includes(bb)?0:1;
        return (pa-pb)||a.localeCompare(b);
      });
    });
    setStatus('Markets ready');
  }catch(err){
    console.warn(err);
    setStatus('Markets unavailable (offline). Try reload');
    EXINFO={symbols:[]}; BY_QUOTE={}; VALID_SET=new Set();
  }
}
function populatePairs(){
  const q=els.quote.value, list=BY_QUOTE[q]||[];
  els.pairs.innerHTML=''; const frag=document.createDocumentFragment();
  list.forEach(s=>{const o=document.createElement('option'); o.value=s; frag.appendChild(o);});
  els.pairs.appendChild(frag);
  if(list.length){
    const cur=els.symbol.value.toUpperCase();
    if(!VALID_SET.has(cur)||!cur.endsWith(q)){
      const pref=list.find(s=>/^(BTC|ETH|BNB|SOL|XRP)/.test(s))||list[0];
      els.symbol.value=pref;
    }
  }else{ els.symbol.value=''; }
}

/* ========= Charts ========= */
const mkChart=(el,opts={})=>{
  const c=LightweightCharts.createChart(el,{
    layout:{background:{type:'solid',color:'transparent'},textColor:'#cfe3ff'},
    grid:{vertLines:{color:'#0e1a28'},horzLines:{color:'#0e1a28'}},
    rightPriceScale:{borderColor:'#223246'},
    timeScale:{borderColor:'#223246',rightOffset:20,barSpacing:8},
    crosshair:{mode:0},
    ...opts
  });
  const resize=()=>c.applyOptions({width:el.clientWidth,height:el.clientHeight});
  new ResizeObserver(resize).observe(el); resize(); return c;
};
const cMain=mkChart($('c-main'));
const cOsc = mkChart($('c-osc'),{rightPriceScale:{visible:true}});

/* Candle/HA series */
let sCandle = cMain.addCandlestickSeries({
  upColor:'#16a34a',downColor:'#ef4444',
  borderUpColor:'#16a34a',borderDownColor:'#ef4444',
  wickUpColor:'#16a34a',wickDownColor:'#ef4444'
});
let haSeries=null;

/* ========= Smarter syncing: attach only when an oscillator is visible ========= */
let syncMainToOsc = null;
let syncOscToMain = null;
let syncing = false;

function attachSync(){
  if(syncMainToOsc || syncOscToMain) return;
  syncMainToOsc = (range)=>{
    if(!range || syncing) return;
    syncing=true; try{ cOsc.timeScale().setVisibleRange(range); }finally{ syncing=false; }
  };
  syncOscToMain = (range)=>{
    if(!range || syncing) return;
    syncing=true; try{ cMain.timeScale().setVisibleRange(range); }finally{ syncing=false; }
  };
  cMain.timeScale().subscribeVisibleTimeRangeChange(syncMainToOsc);
  cOsc.timeScale().subscribeVisibleTimeRangeChange(syncOscToMain);
}
function detachSync(){
  if(syncMainToOsc){
    cMain.timeScale().unsubscribeVisibleTimeRangeChange(syncMainToOsc);
    syncMainToOsc=null;
  }
  if(syncOscToMain){
    cOsc.timeScale().unsubscribeVisibleTimeRangeChange(syncOscToMain);
    syncOscToMain=null;
  }
}

/* ====== Range Guards & Right-Offset Anchor (CENTER-ish) ====== */
let guarding=false;
const ANCHOR_RATIO = 0.45;
function anchorLatestSlightRight(ts){
  const lr = ts.getVisibleLogicalRange?.(); if(!lr || lr.from==null || lr.to==null) return;
  const width = lr.to - lr.from;
  const targetRight = Math.max(2, Math.round(width * ANCHOR_RATIO));
  try{ ts.setRightOffset(targetRight); }catch{}
}
function clampLeftEdge(ts, firstIndex){
  const lr = ts.getVisibleLogicalRange?.(); if(!lr || lr.from==null || lr.to==null) return;
  if(lr.from < firstIndex){
    const w = lr.to - lr.from;
    try{ ts.setVisibleLogicalRange({from:firstIndex, to:firstIndex + w}); }catch{}
  }
}

/* Interaction guard to avoid lag while user drags/scrolls */
let userInteracting=false, interactTimer=null;
const mainHost = document.getElementById('c-main');
['mousedown','touchstart','wheel'].forEach(ev=>{
  mainHost.addEventListener(ev, ()=>{
    userInteracting=true;
    clearTimeout(interactTimer);
    interactTimer=setTimeout(()=>{ userInteracting=false; }, 180);
  }, {passive:true});
});
function installGuards(chart){
  const ts = chart.timeScale();
  const handler = ()=>{
    if(guarding || userInteracting) return;
    guarding = true;
    try{
      clampLeftEdge(ts, 0);
      anchorLatestSlightRight(ts);
    }finally{ guarding = false; }
  };
  ts.subscribeVisibleLogicalRangeChange(handler);
}
installGuards(cMain);

/* ========= Data & Live ========= */
let DATA=[], WS=null, OLDEST_MS=null, LOADING_OLD=false, RECONNECT_TRIES=0;
const MAX_RECONNECT_TRIES=6;
const closeWS=()=>{try{if(WS){WS.onmessage=null;WS.onclose=null;WS.onerror=null;WS.close();}}catch{} WS=null;};

function normalizeSymbolInput(sym, quote){
  if(sym && !sym.endsWith(quote)){
    sym = sym.replace(/(USDT|FDUSD|USDC|BTC|ETH|BNB|TRY)$/,'') + quote;
  }
  return sym;
}
function findAnyMarketSymbolLike(base){
  return (EXINFO.symbols||[]).find(s => (s.status==='TRADING') && s.baseAsset===base)?.symbol;
}

async function fetchKlines(symbol, interval, limit=1000, endTimeMs=null){
  const path = (els.market.value==='spot') ? '/api/v3/klines' : '/fapi/v1/klines';
  const params = new URLSearchParams({ symbol, interval, limit: String(limit) });
  if(endTimeMs) params.set('endTime', String(endTimeMs));
  const url = `${API_BASE}${path}?${params}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('klines fetch failed');
  const raw = await res.json();
  return raw.map(k=>({ tms:k[0], time:Math.floor(k[0]/1000), open:+k[1],high:+k[2],low:+k[3],close:+k[4],volume:+k[5] }));
}

function openWS(symbol, interval){
  closeWS();
  const stream = `${symbol.toLowerCase()}@kline_${interval}`;
  const url = `${WS_URL_BASE}/${stream}`;
  try{
    WS = new WebSocket(url);
  }catch(e){
    console.warn('WS init failed', e);
    setStatus(`Live off • ${symbol} • ${interval}`);
    return;
  }

  WS.onopen=()=>{ RECONNECT_TRIES=0; setStatus(`Live: ${symbol} • ${interval}`); };
  WS.onerror=()=> setStatus(`Socket error • ${symbol} • ${interval}`);
  WS.onclose = ()=> {
    setStatus(`Disconnected • ${symbol} • ${interval}`);
    if(RECONNECT_TRIES < MAX_RECONNECT_TRIES){
      const wait = Math.min(15000, 500 * Math.pow(2, RECONNECT_TRIES));
      RECONNECT_TRIES++;
      setTimeout(()=>openWS(symbol, interval), wait);
    }
  };
  WS.onmessage=(e)=>{ try{
    const msg=JSON.parse(e.data);
    const k = msg.k || msg.data?.k; if(!k) return;
    const t = Math.floor(k.t/1000);
    const bar = { time:t, open:+k.o, high:+k.h, low:+k.l, close:+k.c, volume:+k.v, tms:k.t };
    const last=DATA[DATA.length-1]?.time;
    if(last===t){
      DATA[DATA.length-1] = { ...DATA[DATA.length-1], ...bar };
      sCandle.update(bar);
      if(haSeries){ haSeries.update(HeikinAshi([bar])[0]); }
    }else if(last==null || t>last){
      DATA.push(bar);
      if(DATA.length>5000) DATA.shift();
      sCandle.update(bar);
      if(haSeries){ haSeries.update(HeikinAshi([bar])[0]); }
    }
    Active.forEach(it=>it.update(DATA));
    if(!userInteracting) anchorLatestSlightRight(cMain.timeScale());
  }catch(err){ /* swallow parse/update errors */ } };
}

async function loadInitial(symbol, interval){
  setStatus(`Loading ${symbol} • ${interval} …`);
  DATA = [];
  try{
    const batch = await fetchKlines(symbol, interval, 1000, null);
    if(!batch.length) throw new Error('No data');
    DATA = batch;
    OLDEST_MS = batch[0].tms;

    sCandle.setData(DATA.map(d=>({time:d.time,open:d.open,high:d.high,low:d.low,close:d.close})));
    if(els.haToggle.checked){
      ensureHeikinSeries(); haSeries.setData(HeikinAshi(DATA));
      sCandle.setData([]); // hide native if HA on
    }
    queueMicrotask(()=> cMain.timeScale().scrollToPosition(-2, false));
    setStatus(`History loaded • ${symbol} • ${interval}`);
    Active.forEach(it=>it.update(DATA));
    setTimeout(()=>{ clampLeftEdge(cMain.timeScale(),0); anchorLatestSlightRight(cMain.timeScale()); }, 0);
  }catch(err){
    console.warn(err);
    setStatus('History load failed');
  }
}

/* Backfill on left-edge (scroll) */
function debounce(fn, ms=250){ let t; return (...a)=>{clearTimeout(t); t=setTimeout(()=>fn(...a),ms);} }
const watchBackfill = debounce(async ()=>{
  const rng = cMain.timeScale().getVisibleLogicalRange?.(); if(!rng) return;
  if(rng.from!==undefined && rng.from<20){
    if(LOADING_OLD) return;
    LOADING_OLD=true;
    try{
      const endTime = OLDEST_MS - 1;
      const sym=els.symbol.value.toUpperCase(); const tf=els.tf.value;
      const more = await fetchKlines(sym, tf, 1000, endTime);
      if(more.length){
        OLDEST_MS = more[0].tms;
        DATA = more.concat(DATA);
        sCandle.setData(DATA.map(d=>({time:d.time,open:d.open,high:d.high,low:d.low,close:d.close})));
        if(haSeries){ haSeries.setData(HeikinAshi(DATA)); }
        Active.forEach(it=>it.update(DATA));
      }
    }catch(e){ console.warn(e); }
    LOADING_OLD=false;
  }
},150);
cMain.timeScale().subscribeVisibleLogicalRangeChange?.(watchBackfill);

/* === Optional month loader (12M / 36M) === */
async function loadMonths(months){
  try{
    let sym=els.symbol.value.trim().toUpperCase(), tf=els.tf.value, q=els.quote.value;
    sym = normalizeSymbolInput(sym,q);
    if(!VALID_SET.has(sym)){
      const base=sym.replace(/(USDT|FDUSD|USDC|BTC|ETH|BNB|TRY)$/,'');
      const guess=findAnyMarketSymbolLike(base);
      if(guess){
        const info=(EXINFO.symbols||[]).find(x=>x.symbol===guess);
        if(info){ els.quote.value=info.quoteAsset; populatePairs(); }
        sym=guess;
      }else{
        setStatus('Symbol not found');
        return;
      }
    }
    els.symbol.value=sym;
    setStatus(`Preparing ${months}M • ${sym} • ${tf}`);
    closeWS();

    const nowMs=Date.now(); const approxMonth=30*24*60*60*1000;
    let end=nowMs; const earliest = nowMs - months*approxMonth;
    let out=[];
    while(end>earliest && out.length<200000){
      const batch = await fetchKlines(sym, tf, 1000, end);
      if(!batch.length) break;
      out = batch.concat(out);
      end = batch[0].tms - 1;
      if(out[0].tms<=earliest) break;
      if(out.length%3000===0){
        const pct = Math.min(99, (nowMs-end)/(months*approxMonth)*100);
        setStatus(`Fetching ${months}M • ${sym} • ${tf} • ${pct.toFixed(0)}%`);
      }
    }
    DATA = out;
    OLDEST_MS = out[0]?.tms ?? null;
    sCandle.setData(out.map(d=>({time:d.time,open:d.open,high:d.high,low:d.low,close:d.close})));
    if(els.haToggle.checked){ ensureHeikinSeries(); haSeries.setData(HeikinAshi(DATA)); sCandle.setData([]); }
    Active.forEach(it=>it.update(DATA));
    anchorLatestSlightRight(cMain.timeScale());

    openWS(sym, tf);
    setStatus(`Live: ${sym} • ${tf} • ${months}M`);
    saveLayout();
  }catch(err){ console.warn(err); setStatus(`${months}M load error`); }
}

/* ========= Indicator framework ========= */
const Active=[]; let idSeq=1;
let markerOwners=new Map();
function updateAllMarkers(){ const all=[]; markerOwners.forEach(a=>{a&&all.push(...a)}); try{ sCandle && sCandle.setMarkers(all); }catch{} }

function ensureCandleSeries(){
  if(!sCandle){
    sCandle = cMain.addCandlestickSeries({
      upColor:'#16a34a',downColor:'#ef4444',
      borderUpColor:'#16a34a',borderDownColor:'#ef4444',
      wickUpColor:'#16a34a',wickDownColor:'#ef4444'
    });
  }
}
function ensureHeikinSeries(){
  if(haSeries){ try{ cMain.removeSeries(haSeries);}catch{} }
  haSeries=cMain.addCandlestickSeries({
    upColor:'#22c55e',downColor:'#ef4444',
    borderUpColor:'#22c55e',borderDownColor:'#ef4444',
    wickUpColor:'#22c55e',wickDownColor:'#ef4444',
    priceScaleId:'ha'
  });
  cMain.priceScale('ha').applyOptions({scaleMargins:{top:0.12,bottom:0.12}});
}

/* Layout toggling: only show oscillator row when any osc active */
function anyOsc(){ return Active.some(x=>x.kind==='osc'); }
function refreshOscLayout(){
  if(anyOsc()){
    els.grid.style.gridTemplateRows = 'minmax(260px,1fr) minmax(140px,.55fr)';
    els.oscSlot.style.display='block';
    attachSync();
  }else{
    els.grid.style.gridTemplateRows = '1fr 0px';
    els.oscSlot.style.display='block'; // keep in DOM for sizing, but height is 0px
    detachSync();
  }
}

function badgeLabel(it){const p=Object.entries(it.params).filter(([k])=>k!=='_color').map(([k,v])=>`${k}:${v}`).join(','); return `${it.key}${p?`(${p})`:''}`;}
function renderBadges(){
  els.badges.innerHTML='';
  Active.forEach(it=>{
    const s=document.createElement('span'); s.className='badge'; s.textContent=badgeLabel(it)+' ';
    s.title='Click to edit settings'; s.onclick=()=>openSheet(it.id);
    const b=document.createElement('button'); b.textContent='×'; b.onclick=(e)=>{e.stopPropagation(); removeIndicator(it.id); saveLayout();};
    s.appendChild(b); els.badges.appendChild(s);
  });
  refreshOscLayout();
}
function removeIndicator(id){
  const idx=Active.findIndex(x=>x.id===id);
  if(idx>=0){
    Active[idx].series.forEach(s=>{try{(Active[idx].kind==='osc'?cOsc:cMain).removeSeries(s);}catch{}});
    if(Active[idx].extraCleanup) Active[idx].extraCleanup();
    Active.splice(idx,1); markerOwners.delete(id); updateAllMarkers(); renderBadges();
  }
}

/* Series helpers */
function lineOn(chart,opts={}){ return chart.addLineSeries({lineWidth:2, ...opts}); }
function histOn(chart,extra){ return chart.addHistogramSeries({...extra}); }
function pack(series,updater){ const list=Array.isArray(series)?series:[series]; return {series:list,update:updater}; }
function packOsc(series,updater){ const p=pack(series,updater); return {...p,kind:'osc'}; }
function setLine(series,y){ series.setData(DATA.map((d,i)=>({time:d.time,value:y[i]==null?NaN:y[i]}))); }
function setConstLine(series,val){ series.setData(DATA.map(d=>({time:d.time,value:val}))); }

/* ===== Indicators math (subset) ===== */
const val=o=>o.close;
function SMA(arr,p,acc=val){const out=Array(arr.length).fill(null); let s=0; for(let i=0;i<arr.length;i++){const x=acc(arr[i]); s+=x; if(i>=p) s-=acc(arr[i-p]); if(i>=p-1) out[i]=s/p;} return out;}
function EMA(arr,p,acc=val){const out=Array(arr.length).fill(null); const k=2/(p+1); let prev=null; for(let i=0;i<arr.length;i++){const x=acc(arr[i]); if(prev==null){ if(i>=p-1){ prev=SMA(arr.slice(0,i+1),p,acc)[i]; out[i]=prev;} } else { prev=x*k+prev*(1-k); out[i]=prev; } } return out;}
function ATR(arr,p=14){const out=Array(arr.length).fill(null); let prevC=null,trEMA=null; const k=2/(p+1); for(let i=0;i<arr.length;i++){const h=arr[i].high,l=arr[i].low,c=arr[i].close; const tr=prevC==null?(h-l):Math.max(h-l,Math.abs(h-prevC),Math.abs(l-prevC)); trEMA = trEMA==null? tr : (trEMA*(1-k)+tr*k); out[i]=trEMA; prevC=c;} return out;}
function RSI(arr,p=14){const out=Array(arr.length).fill(null); let g=0,l=0; for(let i=1;i<arr.length;i++){const ch=arr[i].close-arr[i-1].close; const up=Math.max(ch,0),dn=Math.max(-ch,0); if(i<=p){ g+=up; l+=dn; if(i===p){ const rs=(g/p)/((l/p)||1e-12); out[i]=100-100/(1+rs);} } else { g=(g*(p-1)+up)/p; l=(l*(p-1)+dn)/p; const rs=g/(l||1e-12); out[i]=100-100/(1+rs);} } return out;}
function HeikinAshi(arr){const out=[]; let prevO=(arr[0].open+arr[0].close)/2, prevC=(arr[0].open+arr[0].high+arr[0].low+arr[0].close)/4;
  for(let i=0;i<arr.length;i++){
    const c=(arr[i].open+arr[i].high+arr[i].low+arr[i].close)/4;
    const o=(prevO+prevC)/2; const h=Math.max(arr[i].high,o,c), l=Math.min(arr[i].low,o,c);
    out.push({time:arr[i].time,open:o,high:h,low:l,close:c,volume:arr[i].volume}); prevO=o; prevC=c;
  } return out;
}

/* Registry (RSI contains guides; others trimmed for brevity) */
const Registry={
  SMA:{kind:'overlay',params:[{k:'period',v:20,min:1},{k:'_color',v:defaultColor}],add(p){const s=lineOn(cMain); setSeriesColor(s,p._color); return pack(s,A=>s.setData(A.map((d,i)=>({time:d.time,value:SMA(A,p.period)[i]??NaN}))));}},
  EMA:{kind:'overlay',params:[{k:'period',v:50,min:1},{k:'_color',v:defaultColor}],add(p){const s=lineOn(cMain); setSeriesColor(s,p._color); return pack(s,A=>s.setData(A.map((d,i)=>({time:d.time,value:EMA(A,p.period)[i]??NaN}))));}},
  ATR:{kind:'osc',params:[{k:'period',v:14},{k:'_color',v:'#fcd535'}],add(p){const s=lineOn(cOsc); setSeriesColor(s,p._color); return packOsc(s,A=>s.setData(A.map((d,i)=>({time:d.time,value:ATR(A,p.period)[i]??NaN}))));}},
  HeikinAshi:{kind:'overlay',params:[],add(){ensureHeikinSeries(); return {series:[haSeries],update:(A)=>haSeries.setData(HeikinAshi(A)),extraCleanup:()=>{try{cMain.removeSeries(haSeries)}catch{}}};}},
  RSI:{
    kind:'osc',
    params:[
      {k:'period',v:14},
      {k:'_color',v:'#ef4444'},
      {k:'overBought',v:70},
      {k:'obSize',v:1},
      {k:'overSold',v:30},
      {k:'osSize',v:1},
      {k:'showZone',v:true,type:'bool'}
    ],
    add(p){
      const rsiLine = lineOn(cOsc,{lineWidth:2}); setSeriesColor(rsiLine, p._color || '#ef4444');
      const guideOB = lineOn(cOsc,{lineWidth:p.obSize||1}); const guideOS = lineOn(cOsc,{lineWidth:p.osSize||1});
      const guideColor = '#ef4444'; guideOB.applyOptions({color:guideColor}); guideOS.applyOptions({color:guideColor});
      const updater = A=>{
        const r=RSI(A,p.period);
        rsiLine.setData(A.map((d,i)=>({time:d.time,value:r[i]??NaN})));
        guideOB.applyOptions({lineWidth:p.obSize||1}); guideOS.applyOptions({lineWidth:p.osSize||1});
        setConstLine(guideOB, p.overBought ?? 70);
        setConstLine(guideOS, p.overSold ?? 30);
      };
      return packOsc([rsiLine,guideOB,guideOS], updater);
    }
  },
  // (You can re-add the rest of indicators here as needed)
};

/* Presets UI */
function loadPresets(){ try{ return JSON.parse(localStorage.getItem(KEYS.PRESETS)||'{}'); }catch{ return {}; } }
function savePresetsStore(obj){ localStorage.setItem(KEYS.PRESETS, JSON.stringify(obj)); }
function renderPresetDropdown(){ const type=els.indSel.value, all=loadPresets(), list=Object.keys(all[type]||{}); els.presetSel.innerHTML='<option value=\"\">— none —</option>'+list.map(n=>`<option>${n}</option>`).join(''); }
els.indSel.addEventListener('change', ()=>{ renderParams(); renderPresetDropdown(); });

/* Params UI */
function renderParams(){
  const key=els.indSel.value, def=Registry[key];
  els.paramRow.innerHTML='';
  (def.params||[]).forEach(p=>{
    const w=document.createElement('div'); w.className='kvs';
    const lab=document.createElement('label'); lab.className='hint'; lab.textContent=p.k==='_color'?'COLOR':p.k.toUpperCase();
    let inp;
    if(p.type==='bool'){
      inp=document.createElement('input'); inp.type='checkbox'; inp.checked=!!p.v;
    }else{
      inp=document.createElement('input');
      inp.type = (p.k==='_color') ? 'color' : 'number';
      inp.value=p.v;
      if(p.k!=='_color'){ if(p.min!=null) inp.min=p.min; if(p.step!=null) inp.step=p.step; }
    }
    inp.dataset.key=p.k;
    w.appendChild(lab); w.appendChild(inp);
    els.paramRow.appendChild(w);
  });
}
renderParams(); renderPresetDropdown();

function collectParams(){
  const ps={};
  [...els.paramRow.querySelectorAll('input')].forEach(i=>{
    const k=i.dataset.key;
    if(i.type==='color') ps[k]=i.value;
    else if(i.type==='checkbox') ps[k]=i.checked;
    else{
      const step=i.getAttribute('step')||''; const num = step.includes('.') ? parseFloat(i.value) : parseInt(i.value,10);
      ps[k]=isNaN(num)?parseFloat(i.value):num;
    }
  });
  return ps;
}

function addIndicator(){
  const key=els.indSel.value, def=Registry[key], params=collectParams();
  if(params._color==null) params._color=defaultColor;
  const pack=def.add(params);
  setPackColor(pack, params._color);
  const item={id:idSeq++,key,kind:def.kind||'overlay',params,series:pack.series,update:pack.update,extraCleanup:pack.extraCleanup,visible:true};
  Active.push(item);
  renderBadges();
  if(DATA.length) item.update(DATA);
  saveLayout();
}
els.addInd.addEventListener('click', addIndicator);

/* Heikin-Ashi toggle */
els.haToggle.addEventListener('change', ()=>{
  if(!DATA.length) return;
  if(els.haToggle.checked){
    ensureCandleSeries(); ensureHeikinSeries();
    haSeries.setData(HeikinAshi(DATA));
    sCandle.setData([]); // hide native candles when HA on
  }else{
    ensureCandleSeries();
    sCandle.setData(DATA.map(d=>({time:d.time,open:d.open,high:d.high,low:d.low,close:d.close})));
    if(haSeries){ try{cMain.removeSeries(haSeries)}catch{} haSeries=null; }
  }
  updateAllMarkers(); saveLayout();
  if(!userInteracting) anchorLatestSlightRight(cMain.timeScale());
});

/* Settings modal (works for all indicators) */
const sheetWrap=$('sheetWrap'), sheetParams=$('sheetParams'), sheetTitle=$('sheetTitle'), sheetSub=$('sheetSub');
$('sheetClose').onclick=()=>sheetWrap.style.display='none';
function openSheet(id){
  const it=Active.find(x=>x.id===id); if(!it) return;
  sheetTitle.textContent=`${it.key} — Settings`;
  sheetSub.textContent=`ID ${id} • ${it.kind==='osc'?'Oscillator':'Overlay'}`;
  sheetParams.innerHTML='';
  const def=Registry[it.key];
  (def.params||[]).forEach(p=>{
    const val= it.params[p.k] ?? p.v;
    const row=document.createElement('div'); row.className='kv';
    if(p.type==='bool'){
      row.innerHTML = `<label class="hint" style="width:160px">${p.k.toUpperCase()}</label>
        <input type="checkbox" data-k="${p.k}" ${val? 'checked':''} />`;
    }else{
      const type = p.k==='_color' ? 'color' : 'number';
      const extra = p.k==='_color' ? '' : `${p.min!=null?`min="${p.min}"`:''} ${p.step!=null?`step="${p.step}"`:''}`;
      row.innerHTML = `<label class="hint" style="width:160px">${p.k==='_color'?'COLOR':p.k.toUpperCase()}</label>
        <input type="${type}" data-k="${p.k}" value="${val}" ${extra} />`;
    }
    sheetParams.appendChild(row);
  });

  $('sheetApply').onclick=()=>{
    const upd={}; [...sheetParams.querySelectorAll('input')].forEach(i=>{
      const k=i.dataset.k;
      if(i.type==='color') upd[k]=i.value;
      else if(i.type==='checkbox') upd[k]=i.checked;
      else{
        const step=i.getAttribute('step')||''; const num = step.includes('.') ? parseFloat(i.value) : parseInt(i.value,10);
        upd[k]=isNaN(num)?parseFloat(i.value):num;
      }
    });
    const idx=Active.findIndex(x=>x.id===id); const keepKind=Active[idx].kind; const key=Active[idx].key;
    removeIndicator(id);
    const pack=Registry[key].add(upd); setPackColor(pack,upd._color);
    const newItem={id:idSeq++,key,kind:keepKind,params:upd,series:pack.series,update:pack.update,extraCleanup:pack.extraCleanup,visible:true};
    Active.splice(idx,0,newItem); renderBadges(); if(DATA.length) newItem.update(DATA); sheetWrap.style.display='none'; saveLayout();
  };
  $('sheetRemove').onclick=()=>{ removeIndicator(id); sheetWrap.style.display='none'; saveLayout(); };
  $('sheetDuplicate').onclick=()=>{ const p=JSON.parse(JSON.stringify(Active.find(x=>x.id===id).params)); const pack=Registry[it.key].add(p); setPackColor(pack,p._color); const item={id:idSeq++,key:it.key,kind:it.kind,params:p,series:pack.series,update:pack.update,extraCleanup:pack.extraCleanup,visible:true}; Active.push(item); renderBadges(); if(DATA.length) item.update(DATA); saveLayout(); };
  $('sheetToggleVis').onclick=()=>{ const it=Active.find(x=>x.id===id); it.visible=!it.visible; (it.series||[]).forEach(s=>{try{s.applyOptions({visible:it.visible})}catch{}}); };
  sheetWrap.style.display='flex';
}

/* Presets store buttons */
$('savePreset').onclick=()=>{ const key=els.indSel.value; const name=prompt('Preset name?'); if(!name) return; const all=loadPresets(); (all[key] ||= {})[name]=collectParams(); savePresetsStore(all); renderPresetDropdown(); setStatus('Preset saved'); };
$('applyPreset').onclick=()=>{ const key=els.indSel.value; const name=els.presetSel.value; if(!name) return; const all=loadPresets(); const p=all[key]?.[name]; if(!p) return; (els.paramRow.querySelectorAll('input')).forEach(inp=>{ const k=inp.dataset.key; if(k in p){ if(inp.type==='color') inp.value=p[k]; else if(inp.type==='checkbox') inp.checked=!!p[k]; else inp.value=p[k]; } }); setStatus('Preset applied'); };
$('delPreset').onclick=()=>{ const key=els.indSel.value; const name=els.presetSel.value; if(!name) return; const all=loadPresets(); delete (all[key]||{})[name]; savePresetsStore(all); renderPresetDropdown(); setStatus('Preset deleted'); };

/* Layout save/restore */
function saveLayout(){
  const layout={market:els.market.value,quote:els.quote.value,symbol:els.symbol.value,tf:els.tf.value,ha:els.haToggle.checked,indicators:Active.map(x=>({key:x.key,kind:x.kind,params:x.params}))};
  localStorage.setItem(KEYS.LAYOUT, JSON.stringify(layout));
}
function restoreLayout(){
  try{
    const raw=localStorage.getItem(KEYS.LAYOUT); if(!raw) return;
    const L=JSON.parse(raw);
    if(L.market){ els.market.value=L.market; }
    if(L.quote){ els.quote.value=L.quote; }
    populatePairs();
    if(L.symbol){ els.symbol.value=L.symbol; }
    if(L.tf){ els.tf.value=L.tf; }
    if(typeof L.ha==='boolean'){ els.haToggle.checked=L.ha; }
    (L.indicators||[]).forEach(it=>{
      const pack=Registry[it.key]?.add(it.params||{}); if(!pack) return; setPackColor(pack,(it.params||{})._color);
      const item={id:idSeq++,key:it.key,kind:(Registry[it.key].kind||'overlay'),params:(it.params||{}),series:pack.series,update:pack.update,extraCleanup:pack.extraCleanup,visible:true};
      Active.push(item);
    });
    renderBadges(); if(DATA.length){ Active.forEach(i=>i.update(DATA)); }
  }catch{}
}

/* ========= Load flow ========= */
async function loadAll(){
  try{
    applyMarketEndpoints();
    let sym=els.symbol.value.trim().toUpperCase(), tf=els.tf.value, q=els.quote.value;
    sym = normalizeSymbolInput(sym, q);
    if(!VALID_SET.has(sym)){
      const base=sym.replace(/(USDT|FDUSD|USDC|BTC|ETH|BNB|TRY)$/,'');
      const guess=findAnyMarketSymbolLike(base);
      if(guess){
        const info=(EXINFO.symbols||[]).find(x=>x.symbol===guess);
        if(info){ els.quote.value=info.quoteAsset; populatePairs(); }
        sym=guess;
      }else{
        setStatus('Symbol not found'); 
        return;
      }
    }
    els.symbol.value=sym;
    setStatus(`Loading ${sym} • ${tf} …`);
    closeWS();

    await loadInitial(sym, tf);
    openWS(sym, tf);
    saveLayout();
  }catch(err){ console.warn(err); setStatus('Load error'); }
}

/* ========= Events ========= */
$('reload').addEventListener('click', ()=>{ Active.slice().forEach(it=>removeIndicator(it.id)); loadAll(); });
els.tf.addEventListener('change', loadAll);
els.symbol.addEventListener('keydown', e=>{ if(e.key==='Enter') loadAll(); });
els.symbol.addEventListener('change', ()=>{ const v=els.symbol.value.toUpperCase(); if(VALID_SET.has(v)) loadAll(); });
els.quote.addEventListener('change', ()=>{ populatePairs(); loadAll(); });
els.market.addEventListener('change', async ()=>{ try{ await loadExchangeInfo(); populatePairs(); loadAll(); }catch(e){ console.warn(e); setStatus('Failed to switch market'); } });
els.range12.addEventListener('click', ()=> loadMonths(12));
els.range36.addEventListener('click', ()=> loadMonths(36));

/* ========= Boot ========= */
(async function(){
  // Silence unhandled promise errors from UI
  window.addEventListener('unhandledrejection', e=>{ e.preventDefault?.(); console.warn('silenced rejection', e.reason); });
  window.addEventListener('error', e=>{ /* keep console only */ });

  await loadExchangeInfo(); populatePairs();

  try{
    const raw=localStorage.getItem(KEYS.LAYOUT);
    if(raw){
      const L=JSON.parse(raw);
      if(L.market){ els.market.value=L.market; applyMarketEndpoints(); }
      if(L.quote){ els.quote.value=L.quote; }
      populatePairs();
      if(L.symbol){ els.symbol.value=L.symbol; }
      if(L.tf){ els.tf.value=L.tf; }
      if(typeof L.ha==='boolean'){ els.haToggle.checked=L.ha; }
    }
  }catch{}

  if(!els.symbol.value){
    const q=els.quote.value; const def=(BY_QUOTE[q]||[]).find(s=>s.startsWith('BTC')) || (BY_QUOTE[q]||[])[0] || 'BTCUSDT';
    els.symbol.value=def;
  }

  await loadAll();   // initial

  // IMPORTANT: Do NOT auto-add RSI. User must select RSI → Add to show oscillator.
  // Layout restore (may add indicators from previous session)
  restoreLayout();

  // Ensure layout rows consistent on boot
  refreshOscLayout();

  // Final gentle anchor
  setTimeout(()=>{ if(!userInteracting){ clampLeftEdge(cMain.timeScale(), 0); anchorLatestSlightRight(cMain.timeScale()); } }, 50);
})();
</script>
</body>
</html>
